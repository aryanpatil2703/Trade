import { ethers } from 'ethers';

// Contract addresses and ABIs will be auto-generated by deployment script
import DataCoinABI from './contracts/DataCoin.json';
import MarketplaceABI from './contracts/Marketplace.json';


export class ContractManager {
  private provider: ethers.JsonRpcProvider;
  private signer: ethers.Wallet | null = null;
  private dataCoin: ethers.Contract | null = null;
  private marketplace: ethers.Contract | null = null;

  constructor(config: ContractConfig) {
    this.provider = new ethers.JsonRpcProvider(config.rpcUrl);
    
    // Initialize contracts
    if (config.dataCoinAddress && config.marketplaceAddress) {
      this.dataCoin = new ethers.Contract(
        config.dataCoinAddress,
        DataCoinABI.abi,
        this.provider
      );
      
      this.marketplace = new ethers.Contract(
        config.marketplaceAddress,
        MarketplaceABI.abi,
        this.provider
      );
    }
  }

  /**
   * Connect wallet signer
   */
  connectSigner(privateKey: string) {
    this.signer = new ethers.Wallet(privateKey, this.provider);
    
    if (this.dataCoin) {
      this.dataCoin = this.dataCoin.connect(this.signer);
    }
    
    if (this.marketplace) {
      this.marketplace = this.marketplace.connect(this.signer);
    }
  }

  /**
   * Mint a new DataCoin token
   */
  async mintDataCoin(to: string, cid: string): Promise<{ success: boolean; tokenId?: number; txHash?: string; error?: string }> {
    if (!this.dataCoin || !this.signer) {
      return { success: false, error: 'Contract not initialized or signer not connected' };
    }

    try {
      const tx = await this.dataCoin.mintDataCoin(to, cid);
      const receipt = await tx.wait();
      
      // Extract token ID from event logs
      const mintEvent = receipt.logs.find(log => {
        try {
          const parsed = this.dataCoin!.interface.parseLog(log);
          return parsed?.name === 'DataCoinMinted';
        } catch {
          return false;
        }
      });

      let tokenId: number | undefined;
      if (mintEvent) {
        const parsed = this.dataCoin.interface.parseLog(mintEvent);
        tokenId = Number(parsed?.args[0]);
      }

      return {
        success: true,
        tokenId,
        txHash: receipt.hash
      };
    } catch (error) {
      console.error('Mint error:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Minting failed'
      };
    }
  }

  /**
   * List a token for sale
   */
  async listToken(tokenId: number, price: string): Promise<{ success: boolean; txHash?: string; error?: string }> {
    if (!this.dataCoin || !this.signer) {
      return { success: false, error: 'Contract not initialized or signer not connected' };
    }

    try {
      const priceInWei = ethers.parseEther(price);
      const tx = await this.dataCoin.listForSale(tokenId, priceInWei);
      const receipt = await tx.wait();

      return {
        success: true,
        txHash: receipt.hash
      };
    } catch (error) {
      console.error('List error:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Listing failed'
      };
    }
  }

  /**
   * Buy a token
   */
  async buyToken(tokenId: number, value: string): Promise<{ success: boolean; txHash?: string; error?: string }> {
    if (!this.marketplace || !this.signer) {
      return { success: false, error: 'Contract not initialized or signer not connected' };
    }

    try {
      const valueInWei = ethers.parseEther(value);
      const tx = await this.marketplace.buy(tokenId, { value: valueInWei });
      const receipt = await tx.wait();

      return {
        success: true,
        txHash: receipt.hash
      };
    } catch (error) {
      console.error('Buy error:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Purchase failed'
      };
    }
  }

  /**
   * Get token owner
   */
  async getTokenOwner(tokenId: number): Promise<string | null> {
    if (!this.dataCoin) {
      return null;
    }

    try {
      return await this.dataCoin.ownerOf(tokenId);
    } catch (error) {
      console.error('Get owner error:', error);
      return null;
    }
  }

  /**
   * Get token CID
   */
  async getTokenCID(tokenId: number): Promise<string | null> {
    if (!this.dataCoin) {
      return null;
    }

    try {
      return await this.dataCoin.tokenCID(tokenId);
    } catch (error) {
      console.error('Get CID error:', error);
      return null;
    }
  }

  /**
   * Check if token is for sale
   */
  async isTokenForSale(tokenId: number): Promise<boolean> {
    if (!this.dataCoin) {
      return false;
    }

    try {
      return await this.dataCoin.tokenForSale(tokenId);
    } catch (error) {
      console.error('Check sale error:', error);
      return false;
    }
  }

  /**
   * Get token price
   */
  async getTokenPrice(tokenId: number): Promise<string | null> {
    if (!this.dataCoin) {
      return null;
    }

    try {
      const price = await this.dataCoin.tokenPrice(tokenId);
      return ethers.formatEther(price);
    } catch (error) {
      console.error('Get price error:', error);
      return null;
    }
  }

  /**
   * Get contract instances for direct interaction
   */
  getContracts() {
    return {
      dataCoin: this.dataCoin,
      marketplace: this.marketplace,
      provider: this.provider,
      signer: this.signer
    };
  }
}

/**
 * Create contract manager instance
 */
export function createContractManager(): ContractManager {
  const chainId = Number(process.env.NEXT_PUBLIC_CHAIN_ID || 80002);
  
  // Determine RPC URL based on chain ID
  let rpcUrl: string;
  if (chainId === 80002) {
    rpcUrl = process.env.NEXT_PUBLIC_RPC_URL_AMOY || 'https://rpc-amoy.polygon.technology';
  } else if (chainId === 80001) {
    rpcUrl = process.env.NEXT_PUBLIC_RPC_URL_MUMBAI || 'https://polygon-mumbai.g.alchemy.com/v2/demo';
  } else {
    rpcUrl = process.env.NEXT_PUBLIC_RPC_URL || 'https://rpc-amoy.polygon.technology';
  }

  const config: ContractConfig = {
    dataCoinAddress: process.env.NEXT_PUBLIC_DATACOIN_CONTRACT_ADDRESS || '',
    marketplaceAddress: process.env.NEXT_PUBLIC_MARKETPLACE_CONTRACT_ADDRESS || '',
    chainId,
    rpcUrl
  };

  return new ContractManager(config);
}
